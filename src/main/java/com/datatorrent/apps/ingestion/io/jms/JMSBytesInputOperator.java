/*
 *  Copyright (c) 2015 DataTorrent, Inc.
 *  All Rights Reserved.
 */
package com.datatorrent.apps.ingestion.io.jms;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.util.Enumeration;

import javax.jms.BytesMessage;
import javax.jms.JMSException;
import javax.jms.MapMessage;
import javax.jms.Message;
import javax.jms.ObjectMessage;
import javax.jms.StreamMessage;
import javax.jms.TextMessage;

import com.datatorrent.lib.io.jms.AbstractJMSInputOperator;

/**
 * JMS input operator for which outputs byte[]
 */
public class JMSBytesInputOperator extends AbstractJMSInputOperator<byte[]>
{

  /**
   * Separator for key value pair in Map message
   */
  private String keyValueSeparator = ":";
  
  /**
   * Separator for (key:value) entry in Map message
   */
  private String entrySeparator = ",";
  
  /* (non-Javadoc)
   * @see com.datatorrent.lib.io.jms.AbstractJMSInputOperator#convert(javax.jms.Message)
   */
  @Override
  protected byte[] convert(Message message) throws JMSException
  {
    if(message instanceof TextMessage){
      return ((TextMessage)message).getText().getBytes();
    }
    else if(message instanceof StreamMessage){
      return ((StreamMessage) message).readString().getBytes();
    }
    else if(message instanceof BytesMessage){
      BytesMessage bytesMessage = (BytesMessage) message;
      byte[] bytes = new byte[(int)bytesMessage.getBodyLength()];
      bytesMessage.readBytes(bytes);
      return bytes;
    }
    else if(message instanceof MapMessage){
      return readMapMessage((MapMessage) message);
    }
    else if(message instanceof ObjectMessage){
      try {
        return readObjectMessage((ObjectMessage) message);
      } catch (IOException e) {
        throw new RuntimeException(e);
      }
    }
    throw new IllegalArgumentException("Message Type " + message.getJMSType() + " is not supported.");
  }
  
  

  /* (non-Javadoc)
   * @see com.datatorrent.lib.io.jms.AbstractJMSInputOperator#emit(java.lang.Object)
   */
  @Override
  protected void emit(byte[] payload)
  {
    output.emit(payload);
  }
  
  /**
   * Extract a byte[] from the given {@link MapMessage}.
   * byte[] representation of String generated by iterating over key: value pairs.
   * Key and value are separated using <code>keyValueSeparator</code>.
   * (Key:Value) entries are separated using <code>entrySeparator</code>.
   * 
   * @param message the message to convert
   * @return the resulting byte[]
   * @throws JMSException if thrown by JMS methods
   */
  protected byte[] readMapMessage(MapMessage message) throws JMSException
  {
    StringBuffer sb = new StringBuffer();
    Enumeration<?> en = message.getMapNames();
    sb.append("{");
    while(en.hasMoreElements()){
      String key = (String) en.nextElement();
      sb.append(key);
      sb.append(keyValueSeparator);
      sb.append(message.getObject(key));
      sb.append(entrySeparator);
      
    }
    sb.append("}\n");
    return sb.toString().getBytes();
  }

  /**
   * Extract a byte[] from the given {@link ObjectMessage}.
   *
   * @param message the message to convert
   * @return the resulting byte[]
   * @throws JMSException if thrown by JMS methods
   * @throws IOException 
   */
  protected byte[] readObjectMessage(ObjectMessage message) throws JMSException, IOException
  {
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    ObjectOutputStream oos = new ObjectOutputStream( baos );
    try{
      oos.writeObject(message.getObject());
      return baos.toByteArray();
    }
    finally{
      oos.close();
    }
  }
  
  /**
   * @return the keyValueSeparator
   */
  public String getKeyValueSeparator()
  {
    return keyValueSeparator;
  }
  
  /**
   * @param keyValueSeparator the keyValueSeparator to set
   */
  public void setKeyValueSeparator(String keyValueSeparator)
  {
    this.keyValueSeparator = keyValueSeparator;
  }
  
  /**
   * @return the entrySepertor
   */
  public String getEntrySeparator()
  {
    return entrySeparator;
  }
  
  /**
   * @param entrySepertor the entrySepertor to set
   */
  public void setEntrySeparator(String entrySeparator)
  {
    this.entrySeparator = entrySeparator;
  }

}
