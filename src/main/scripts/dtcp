#!/bin/bash
# DataTorrent Gateway management utility.
# For more info see docs on http://www.datatorrent.com/
#
# Authors: Sandeep Deshmukh (sandeep@datatorrent.com)
#          Devendra Vyavhare (devendra@datatorrent.com)
#   
# Copyright: (c) 2014 DataTorrent, Inc. All rights reserved.


#------------------------------------------------------------------------------
# Support functions
#------------------------------------------------------------------------------
log() { printf "%b\n" "$*"; }
info() { log "$*" ; }
warn() { log "WARNING: $*" ; }
debug() { (( ${verbose} )) && log "DEBUG: $*"; }
error() { log "\nERROR: $*\n" ; }

# Produces real directory based on input with all the links resolved
# Following http://stackoverflow.com/questions/59895/can-a-bash-script-tell-what-directory-its-stored-in
real_dir() {
  SOURCE="${1:-${BASH_SOURCE[0]}}"
  while [ -h "$SOURCE" ]; do # resolve $SOURCE until the file is no longer a symlink
    SOURCE_DIR="$( cd -P "$( dirname "$SOURCE" )" && pwd )"
    SOURCE="$(readlink "$SOURCE")"
    [[ $SOURCE != /* ]] && SOURCE="$SOURCE_DIR/$SOURCE" # if $SOURCE was a relative symlink, we need to resolve it relative to the path where the symlink file was located
  done
  SOURCE_DIR="$( cd -P "$( dirname "$SOURCE" )" && pwd )"
  echo "$SOURCE_DIR"
}

#------------------------------------------------------------------------------
# Default settings
#------------------------------------------------------------------------------
fg_mode=0
service_mode=0
script_dir=$(real_dir "${BASH_SOURCE[0]}")
script_name=$(basename "${BASH_SOURCE[0]}")

# Provide instructions for using the installation script
usage(){
cat << USAGE

DataTorrent Ingestion Application"

Usage:
$0 [-f filefilter] [--fastMerge] [--scanInterval scanInterval] [--originalAppId appId] [-w] [-r] [-e] [--keyFile keyFilePath] [-c] -j IngestionAppPackge sourceURL(s) destinationURL

 -j : IngestionApp jar file
 -f : filter for reading files from input source (default=read all files)
 -r : recursive copy of input sources
 --fastMerge : enable fast merge (only on HDFS where IngestionAPP is running)
 --scanInterval : directory scan interval in h|m|s format e.g. 10h or 10m or 10s
 --originalAppId : specify original application identifier for restart
 -w : overwrite if file exists in destination directory (default=off)
 -e : set encryption
 --keyFle : KeyFile path for encryption
 -c : set compression

USAGE
}


process_options() {
    while true; do
        case "$1" in
            -j|--jarfile) DT_APP=${2}; shift; shift;;
            -f|--filter) filter=${2}; shift; shift;;
            -r|--recursive) recursive=true; shift;;
            --fastMerge) fastMerge=true; shift;;
            --scanInterval) scanInterval=${2}; shift; shift;;
            --originalAppId) originalAppId=${2}; shift; shift;;
            -w|--overwrite) overwrite=true; shift;;
            -e|--encrypt) encrypt=true; shift;;
            -c|--compress) compress=true; shift;;
            --keyFile) keyFilePath=${2}; shift; shift;;
            *) open_string=$open_string" "${1}; if [ "${1}" == "" ];then break; fi; shift;;
        esac
    done
}


load_dt_env() {

    # Load DataTorrent environment settings
    # DT_HADOOP is searched or loaded from user settings via sfw-env.sh
    # DT_JAVA is searched or loaded from user settings via sfw-env.sh
    # DT_CLASSPATH is loaded via dt-env.sh
    for conf_dir in "${script_dir}/../conf" "$HOME/.dt"; do
        if [[ -f "${conf_dir}/dt-env.sh" ]]; then
            DT_CONF_DIR="${conf_dir}"
            DT_ENV_SH="${conf_dir}/dt-env.sh"
            . "${DT_ENV_SH}"
        fi
    done

    # Set defaults in case environment settings are missing
    DT_BASE_DIR=${DT_BASE_DIR:-"$HOME/.dt"}
    DT_RUN_DIR=${DT_RUN_DIR:-"$HOME/.dt/run"}
    DT_LOG_DIR=${DT_LOG_DIR:-"$HOME/.dt/logs"}
    DATATORRENT_HOME=${DATATORRENT_HOME:-"$DT_BASE_DIR/current"}
    [[ -d ${DATATORRENT_HOME}/ ]] || DATATORRENT_HOME="${script_dir}/.."

    # In development mode, if configuration files are not found, locate DT_HADOOP manually
    if [ -z "${DT_HADOOP}" ]; then
      HADOOP_SEARCH_PATH="${HADOOP_PREFIX}/bin:${HADOOP_HOME}/bin:${PATH}:/usr/local/bin:/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/sbin:."
      DT_HADOOP=`PATH=${HADOOP_SEARCH_PATH} && command -v hadoop 2>/dev/null`
    fi

    # If gateway is not running as service, and local ~/.dt/dt-env.sh override is missing
    # change run and logs directories to be local
    if [ ${service_mode} -ne 1 ] &&  ! [ -f "$HOME/.dt/dt-env.sh" ]; then
        # debug "Setting logs and run directory base to $HOME/.dt due to missing $HOME/.dt/dt-env.sh"
        DT_LOG_DIR="${HOME}/.dt/logs"
        DT_RUN_DIR="${HOME}/.dt/run"
    fi


}

set_dtcp_env() {
    
    # Load DataTorrent environment files
    load_dt_env

    # Ensure DATATORRENT_HOME is set and exported - used by DTGateway
    export DATATORRENT_HOME

    # Define classpaths
    DT_DTCP_CLASSPATH="${DT_CLASSPATH}"

    # Add development support by loading maven classpath settings
    BUILD_DIR="$( cd ${script_dir}/../../../target 2>/dev/null && pwd -P)"
    MVN_GENERATED_PATH="$BUILD_DIR/mvn-generated-runtime-classpath-no-hadoop"
    if [ -f "$MVN_GENERATED_PATH" ]; then
        #info "Development launch mode.  Setting classpath from: $MVN_GENERATED_PATH"
        DT_DTCP_CORE_JAR=`ls $BUILD_DIR/DTApp-ingestion-app*.jar | grep -Ev "tests.jar|javadoc.jar|sources.jar" | tail -1`
        if [ -f "$DT_DTCP_CORE_JAR" ]; then
            DT_DTCP_CLASSPATH="$DT_DTCP_CLASSPATH:$DT_DTCP_CORE_JAR"
        else
            error "Cannot find $DT_DTCP_CORE_JAR";
            exit 1;
        fi
        if [ ! -x "$DT_HADOOP" ]; then
            error "Unable to continue due to missing hadoop executable.  Please ensure it is available in PATH.";
            exit 1;
        fi
        DT_DTCP_CLASSPATH="$DT_DTCP_CLASSPATH:`cat $MVN_GENERATED_PATH`"
    else
      DT_DTCP_CLASSPATH="$DATATORRENT_HOME/lib"'/*'":${DT_DTCP_CLASSPATH}"
    fi

    # Add missing $script_dir directories only if not already in $PATH
    echo "$PATH" | grep "$script_dir" > /dev/null
    if [[ $? -ne 0 ]]; then
        export PATH=$script_dir/../../../../stram/src/main/scripts:$script_dir:$PATH
    fi

}


set_relaunch_parameters() {
  inputurl="dummyUrl"
  outputurl="dummyurl"
}

check_parameters(){

# Validate input JAR
if [ "$DT_APP" == "" ]
then
    echo "JAR file name missing"
    usage;
    echo ;
    exit 1 ;
fi

# parse open_string
words=( $open_string )
len="${#words[@]}"
if [ $len -gt 1 ];
then
  inputurl=${words[0]};
  outputurl=${words[$len-1]}
fi

end=$(($len-2))
for x in `seq 1 $end`;
do
    inputurl=$inputurl","${words[$x]};
done;

# Validate output URL
if [ "$outputurl" == "" ]
then
    echo "Mandatory output URL is missing. Exiting".
    usage ;
    exit 1 ;
fi

# Validate input URL
if [ "$inputurl" == "" ]
then
    echo "Mandatory input URL is missing."
    usage;
    echo ;
    exit 1 ;
fi

input_protocol=`echo $inputurl | awk -F":" '{print $1}' `
output_protocol=`echo $outputurl | awk -F":" '{print $1}' `

if [ $input_protocol == "kafka" ]
then
  topic=`echo $inputurl | awk -F/ '{print $3}'`
  zookeeperlist=`echo $inputurl | awk -F/ '{print $4}'`
fi


if [ $input_protocol == "jms" ]
then
  brokerURL=`echo $inputurl | awk -F/ '{print $3}'`
  subject=`echo $inputurl | awk -F/ '{print $4}'`
  DT_INGESTION_APP="JMSMessageIngestionApp"
fi

if [ ! -z "$originalAppId" ]
then
  launchArgs="$launchArgs -originalAppId $originalAppId";
fi
}

parse_scantime() {
  unit=${scanInterval: -1}
  case "$unit" in
    "h") sec=`expr 60 \* 60`;
    ;;
    "m") sec=60;
    ;;
    "s") sec=1;
    ;;
    *)
      echo "Enter valid unit for scanInterval it should be in either h, m or s e.g. 10h or 10m or 10s" >&2
      exit 1;
    ;;
  esac
  time=${scanInterval::-1}
  re='^[0-9]+$'
  if ! [[ $time =~ $re ]]
  then
   echo "Enter valid number for scanInterval" >&2
   exit 1;
  fi
  totalMS=`expr $time \* $sec \* 1000`
  echo $totalMS
}

create_xml(){

CONF_FILE=/tmp/dtcp.$MYPID;
touch $CONF_FILE;
if [ $? -ne 0 ]
then
  echo "Unable to create tmp file $CONF_FILE . Exiting."
  exit 1;
fi


cat  > $CONF_FILE << EOF
<configuration>
  <property>
    <name>dt.operator.FileSplitter.prop.scanner.files</name>
    <value>$inputurl</value>
  </property>

  <property>
    <name>dt.operator.FileMerger.prop.filePath</name>
    <value>$outputurl</value>
  </property>

EOF

if [ ! -z "$filter" ]
then
cat >> $CONF_FILE << FILTER
  <property>
    <name>dt.operator.FileSplitter.prop.scanner.filePatternRegularExp</name>
    <value>$filter</value>
  </property>
FILTER
fi

if [ ! -z "$recursive" ]
then
cat >> $CONF_FILE << RECURSIVE
  <property>
    <name>dt.operator.FileSplitter.prop.scanner.recursive</name>
    <value>$recursive</value>
  </property>
RECURSIVE
fi


if [ ! -z "$overwrite" ]
then
cat >> $CONF_FILE << OVERWRITE
  <property>
    <name>dt.operator.FileMerger.prop.overwriteOutputFile</name>
    <value>$overwrite</value>
  </property>
OVERWRITE
fi

if [ ! -z "$encrypt" ]
then
cat >> $CONF_FILE << ENCRYPT
  <property>
    <name>dt.application.Ingestion.encrypt</name>
    <value>$encrypt</value>
  </property>
ENCRYPT

if [ ! -z "$keyFilePath" ]
then
cat >> $CONF_FILE << KEYFILE
  <property>
    <name>dt.application.Ingestion.secretKeyFile</name>
    <value>$keyFilePath</value>
  </property>
KEYFILE
fi
fi

if [ ! -z "$compress" ]
then
cat >> $CONF_FILE << COMPRESS
  <property>
    <name>dt.application.Ingestion.compress</name>
    <value>$compress</value>
  </property>
COMPRESS
fi

case $input_protocol in 
    "kafka")
    cat >> $CONF_FILE << KAFKA
  <property>
    <name>dt.application.Ingestion.operator.MessageReader.prop.topic</name>
    <value>$topic</value>
  </property>
  <property>
    <name>dt.application.Ingestion.operator.MessageReader.prop.zookeeper</name>
    <value>$zookeeperlist</value>
  </property>
  <property>
    <name>dt.application.Ingestion.operator.fileWriter.prop.filePath</name>
    <value>$outputurl</value>
  </property>
  <property>
    <name>dt.application.Ingestion.operator.fileWriter.prop.maxLength</name>
    <value>67108864</value>
  </property>
KAFKA
;;
    "jms")
    cat >> $CONF_FILE << JMS
  <property>
    <name>dt.application.JMSMessageIngestionApp.operator.MessageReader.prop.connectionFactoryProperties.brokerURL</name>
    <value>tcp://$brokerURL</value>
  </property>
  <property>
    <name>dt.application.JMSMessageIngestionApp.operator.MessageReader.prop.ackMode</name>
    <value>AUTO_ACKNOWLEDGE</value>
  </property>
  <property>
    <name>dt.application.JMSMessageIngestionApp.operator.MessageReader.prop.subject</name>
    <value>$subject</value>
  </property>
  <property>
    <name>dt.application.JMSMessageIngestionApp.operator.fileWriter.prop.filePath</name>
    <value>$outputurl</value>
  </property>
  <property>
    <name>dt.application.JMSMessageIngestionApp.operator.fileWriter.prop.maxLength</name>
    <value>67108864</value>
  </property>
JMS
;;
    "s3"| "s3n"| "ftp")
cat >>  $CONF_FILE << AUTH_PROTOCOL
  <property>
    <name>dt.operator.BlockReader.prop.uri</name>
    <value>$inputurl</value>
  </property>
AUTH_PROTOCOL
;;

    "hdfs")
cat >>  $CONF_FILE << HDFS
  <property>
    <name>dt.operator.FileSplitter.prop.scanner.ignoreFilePatternRegularExp</name>
    <value>.*\._COPYING_</value>
  </property>
HDFS
;;
    
esac # end of case statement for input_protocol


if [ ! -z "$input_protocol" ]
then
cat >>  $CONF_FILE << INPUTPROTOCOL
  <property>
    <name>dt.operator.BlockReader.prop.scheme</name>
    <value>$input_protocol</value>
  </property>
INPUTPROTOCOL
fi

cat >> $CONF_FILE << OUTPUTPROTOCOL
  <property>
    <name>dt.output.protocol</name>
    <value>$output_protocol</value>
  </property>
OUTPUTPROTOCOL

if [ ! -z "$fastMerge" ]
then
cat >> $CONF_FILE << FASTMERGE
  <property>
    <name>dt.output.enableFastMerge</name>
    <value>$fastMerge</value>
  </property>
FASTMERGE
fi

if [ ! -z "$scanInterval" ]
then
interval=$( parse_scantime )
if [[ $? != 0 ]]
then
  exit 1;
fi
cat >> $CONF_FILE << EOF
  <property>
    <name>dt.operator.FileSplitter.prop.scanner.scanIntervalMillis</name>
    <value>$interval</value>
  </property>
EOF
fi

echo "</configuration>" >> $CONF_FILE 
}


launch_app() {
  # Search for Ingestion application name. This needs to move to setupDtcpEnv() when that is integrated with the script.
  DT_INGESTION_APP=${DT_INGESTION_APP:=Ingestion}
  echo ;
  echo ;
  echo "Launching app..."
        echo launch -conf $CONF_FILE $launchArgs $DT_APP -exactMatch $DT_INGESTION_APP ;
    if [ ! -z "$DTCP_TEST_MODE" ]
    then
        # Test  mode will only create the conf file and will skip launching the app.
        # Used for testing dtcp script (internal, not exposed to the users)
        exit 0;
    else
         echo launch -conf $CONF_FILE $launchArgs $DT_APP -exactMatch $DT_INGESTION_APP | dtcli
    fi
}



#------------------------------------------------------------------------------
# Process user input and execute requested action
#------------------------------------------------------------------------------
# Confirm at at least one argument was provided
if [ -z $1 ]; then
  usage;
  exit 1;
fi

script_opts="$@"

# Process remaining action options
process_options ${script_opts}
if [ ! -z "$originalAppId" ]
then
  set_relaunch_parameters
fi
check_parameters

script_dir=$(real_dir "${DT_APP}")
script_name=$(basename "${DT_APP}")

MYPID=$BASHPID;

create_xml

launch_app

